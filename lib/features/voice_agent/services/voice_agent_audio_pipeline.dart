import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter_sound/flutter_sound.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:record/record.dart';
import 'package:voxia/voxia.dart';

/// Contract for supplying microphone input and handling AI-generated audio.
abstract class VoiceAgentAudioPipeline {
  /// Whether the microphone capture and audio playback pieces are ready.
  bool get isReady;

  /// Ensures the underlying audio recorder/player are initialised and ready.
  Future<void> ensureReady();

  /// Called whenever the orchestrator needs a stream of PCM16 audio.
  Future<Stream<Uint8List>> createInputStream(Question question);

  /// Called for each audio chunk generated by the AI assistant.
  Future<void> handleOutput(Uint8List audioBytes);

  /// Resets any in-flight recording or playback state between sessions.
  Future<void> reset();

  /// Releases any OS resources (microphone, audio session, etc.).
  Future<void> dispose();
}

/// Placeholder implementation that throws to remind developers to wire in
/// their audio recording and playback services.
class PlaceholderVoiceAgentAudioPipeline implements VoiceAgentAudioPipeline {
  @override
  bool get isReady => false;

  @override
  Future<void> ensureReady() async {}

  @override
  Future<Stream<Uint8List>> createInputStream(Question question) async {
    throw UnimplementedError(
      'Replace PlaceholderVoiceAgentAudioPipeline with a real implementation '
      'that streams PCM16 microphone audio to Gemini Live.',
    );
  }

  @override
  Future<void> handleOutput(Uint8List audioBytes) async {
    throw UnimplementedError(
      'Replace PlaceholderVoiceAgentAudioPipeline with a real implementation '
      'that plays back AI-generated PCM16 audio.',
    );
  }

  @override
  Future<void> reset() async {}

  @override
  Future<void> dispose() async {}
}

/// Audio pipeline that records PCM16 microphone audio using the `record`
/// package and plays AI responses via `flutter_sound`.
class FlutterSoundVoiceAgentPipeline implements VoiceAgentAudioPipeline {
  FlutterSoundVoiceAgentPipeline({
    AudioRecorder? recorder,
    FlutterSoundPlayer? player,
  })  : _recorder = recorder ?? AudioRecorder(),
        _player = player ?? FlutterSoundPlayer();

  final AudioRecorder _recorder;
  final FlutterSoundPlayer _player;

  StreamSubscription<Uint8List>? _recordingSubscription;
  StreamController<Uint8List>? _currentInputController;
  Future<void>? _initialising;
  bool _isReady = false;
  bool _isPlayerStreaming = false;

  @override
  bool get isReady => _isReady;

  @override
  Future<void> ensureReady() async {
    if (_isReady) return;
    if (_initialising != null) {
      await _initialising;
      return;
    }
    _initialising = _prepare();
    try {
      await _initialising;
    } finally {
      _initialising = null;
    }
  }

  Future<void> _prepare() async {
    final permission = await Permission.microphone.request();
    if (!permission.isGranted) {
      throw VoxiaException(
        'Microphone permission denied. Enable it in system settings to use the voice agent.',
      );
    }

    final hasPermission = await _recorder.hasPermission();
    if (!hasPermission) {
      throw VoxiaException('Microphone permission not granted to recorder.');
    }

    try {
      await _player.openPlayer();
    } catch (error, stackTrace) {
      debugPrint('Failed to open FlutterSound player: $error\n$stackTrace');
      throw VoxiaException('Unable to open audio playback session.',
          cause: error);
    }

    _isReady = true;
  }

  @override
  Future<Stream<Uint8List>> createInputStream(Question question) async {
    if (!_isReady) {
      throw VoxiaException('Audio pipeline is not initialised.');
    }

    await resetRecording();

    final recordStream = await _recorder.startStream(
      const RecordConfig(
        encoder: AudioEncoder.pcm16bits,
        sampleRate: 16000,
        numChannels: 1,
        bitRate: 256000,
        streamBufferSize: 4096,
      ),
    );

    final controller = StreamController<Uint8List>();
    _currentInputController = controller;

    _recordingSubscription = recordStream.listen(
      (chunk) {
        controller.add(Uint8List.fromList(chunk));
      },
      onError: (Object error, StackTrace stackTrace) {
        controller.addError(error, stackTrace);
      },
      onDone: () {
        if (!controller.isClosed) {
          controller.close();
        }
      },
      cancelOnError: true,
    );

    controller.onCancel = () async {
      await resetRecording();
    };

    return controller.stream;
  }

  @override
  Future<void> handleOutput(Uint8List audioBytes) async {
    if (!_isReady || audioBytes.isEmpty) {
      return;
    }

    await _ensurePlayerStreaming();
    try {
      await _player.feedUint8FromStream(audioBytes);
    } catch (error, stackTrace) {
      debugPrint('Failed to feed audio stream: $error\n$stackTrace');
    }
  }

  Future<void> _ensurePlayerStreaming() async {
    if (_isPlayerStreaming) return;
    try {
      await _player.startPlayerFromStream(
        codec: Codec.pcm16,
        interleaved: true,
        numChannels: 1,
        sampleRate: 16000,
        bufferSize: 4096,
      );
      _isPlayerStreaming = true;
    } catch (error, stackTrace) {
      debugPrint('Failed to start player stream: $error\n$stackTrace');
      throw VoxiaException('Unable to start audio playback stream.',
          cause: error);
    }
  }

  Future<void> resetRecording() async {
    await _recordingSubscription?.cancel();
    _recordingSubscription = null;

    if (await _recorder.isRecording()) {
      await _recorder.stop();
    }

    await _currentInputController?.close();
    _currentInputController = null;
  }

  Future<void> resetPlayback() async {
    if (_isPlayerStreaming) {
      try {
        await _player.stopPlayer();
      } catch (error) {
        debugPrint('Failed to stop player: $error');
      }
      _isPlayerStreaming = false;
    }
  }

  @override
  Future<void> reset() async {
    await resetRecording();
    await resetPlayback();
  }

  @override
  Future<void> dispose() async {
    await reset();
    try {
      await _player.closePlayer();
    } catch (_) {}
    await _recorder.dispose();
    _isReady = false;
  }
}
